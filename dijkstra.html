<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra Algorithm</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.3.2/math.js"></script>
</head>

<body style="background-color: black;">
    <h1>The Shortest Path to Destination</h1>
    <h3 class="introh3" style="text-align: center; font-size: 30px; margin-top: 10px; ">DIJKSTRA ALGORITHM</h3>
    <div class="card" style="background-color: black;">
        <div class="card-content">
            <div>
                <h3 class="introh3">Introduction :</h3>
            </div>
            <div style="margin-left: 50px;">
            <P>Dijkatra algorithm is useful in finding the shortest path between two nodes of non - negative weighted graphs. It was invented by " Dr. Edsger W. Dijkstra, a brilliant Dutch computer scientist and software engineer. This algorithm exists in many variants, Dijkstra's original algorithm found the shortest path between two any given nodes, but a more common variant fixes a single node as the source node and finds shortest paths from the source to all other remaining nodes of the graph, hence producing a shortest-path tree. It can also be used to find the shortest distance from source node and stopping the algorithm as we reach destinated node. Dijkstra's algorithm is widely used in network routing protocol, such as Intermediate System to Intermediate System (IS-IS) and Open Shortest Path First (OSPF).It uses Greedy approach.</P>
            </div>
            <h3 class="introh3">Illustration :</h3>
            <div style="text-align: center;">
                <img src="./images/image1.png">
            </div>
            <p>We can phrase the cost matrix based upon the graph given above,</p>
            <div class="container">
                <div class="text">
                    <p>Cost Matrix :</p>
                </div>
                <div class="img">
                    <img src="./images/matrix.png">
                </div>
            </div>
            <div style="display: flex;">
                <ul>
                    <li>The cost matrix would be of the order [node][node], where, node = The number of nodes in graphs.
                    </li>
                    <li>The [row][column] will be the distance between two nodes, which is basically defined as the cost
                        of going from one node to another.</li>
                    <li>The distance of the node from itself is taken to be Infinity.</li>
                    <li>The value of [row][column] which are independent from each other, i.e., there is no direct path
                        between them, is taken to be infinity.</li>
                </ul>
            </div>
            <br>
            <div>
                <ul>
                    <li>There is also a need to keep track of,</li>
                </ul>
                <ol>
                    <li style="margin-left: 55px;">Distance array : It will store the minimum distance from the
                        source node to all the other respective nodes.</li>
                    <li style="margin-left: 55px;">Visit_check array : It will store the track of the nodes that are
                        already visited once.
                    </li>
                    <li style="margin-left: 55px;">Parent Array : It will store the path of the parent nodes for all
                        the nodes other than source node.
                    </li>
                </ol>
            </div>
            <div style="text-align: center;">
                <h3 class="introh3" style="padding-top: 20px; padding-bottom: 20px;">The procedure of the Dijkstra</h3>
            </div>
            <div>
                <ol>
                    <li>Firstly, initialize the distance_array[node] with infinity, i.e., it will store the maximum
                        possible distance between two nodes.</li>
                    <li>Now, assign the distance[source] to be zero, because that will be the starting point to enter
                        the graph and start computing the algorithm.</li>
                    <li>Similarly, initialize the Visit_check[node] to be false.</li>
                    <li>And, initialize, the Parent[node] with zero.</li>
                    <div style="text-align: center;">
                        <p>Distance_[4] : [∞ ∞ ∞ ∞]</p>
                        <p>Visit_check[4] : [F F F F]</p>
                        <p>Parent[4] : [0 0 0 0 ] </p>
                    </div>
                    <li>Now, the user will provide the values for the source node i.e., his current location and the
                        final node i.e., where he wishes to reach.</li>
                </ol>
            </div>
            <div>
                <p><b>Iteration-1 :</b></p>
                <div style="margin-left: 50px;">
                    <ul>
                        <li>Start with the source node.</li>
                        <li>We are defining Minimum_value and its index (Minimum_index), to compare with the other
                            nodes.</li>
                        <li>Compare the distance[node] with the Minimum_value, which will be initialially kept infinity
                            and assign it that value if,</li>
                    </ul>
                    <p>
                       <div style="text-align: center;"> <p>(Distance[node] < Minimum_value) AND (Visit_check[node]==False)</p></div> <div
                            style="text-align: center;">
                            <p>Minimum_value = 0</p>
                            <p>Minimum_index = 0</p>
                </div>
                </p>
                <ul>
                    <li>Now, mark the index which is visted in the Visit_check array.</li>
                </ul>
                <div style="text-align: center;">
                    <p>Visit_check[4] : [T F F F]</p>
                </div>
                <ul>
                    <li>Now, check the minimum distance between its adjacent nodes, by a loop which will execute only if
                        all below conditions are true,</li>
                </ul>
                <div>
                    <ol>
                        <div style="margin-left: 450px;"><li>visit_check[node] == False</li></div>
                        <div style="margin-left: 250px;"><li>distance[Minimum_index] + cost[Minimum_index][Node] < distance[Node]</li></div>
                        <div style="margin-left: 400px;"><li>cost[Minimum_index][Node] != Infinity </li></div>
                    </ol>
                </div>
            </div>
            <div style="margin-left: 400px;">
                <ul>
                    <li>i = 0 : Not execute, as Visit_check is True.</li>
                    <li>i = 1 : Since ( 0 + 5 ) < ∞, Distance_[4] : [0 5 ∞ ∞]</li>
                    <li>i = 2 : Since ( 0 + 8 ) < ∞, Distance_[4] : [0 5 8 ∞]</li>
                    <li>i = 3 : Since ( 0 + ∞) = ∞,Distance_[4]  : [ 0 5 8 ∞]</li>
                </ul>
            </div>
            <div style="text-align: center;">
                <p>And assign Parent[Node] = Minimum_index</p>
            </div>
            <div>
                <p><b>Iteration-2 :</b></p>
                <ul><li>Again,Minimum_Value = 5 & Minimum_index = 1</li></ul>
            </div>
            <div>
                <ul>
                    <li>Now, mark the index which is visited in the Visit_check array.</li>
                    <div style="text-align: center;">
                        <p>Visit_check[4] : [T T F F]</p>
                    </div>
                    <li>Now, check the minimum distance between its adjacent nodes, by a loop which will execute only if,</li>
                    <div style="margin-left: 400px;">
                        <ul>
                            <li>i = 0 : Not execute, as Visit_check is True.</li>
                            <li>i = 1 : Not execute, as Visit_check is True.</li>
                            <li>i = 2 : Since ( 5 + 9 ) > 8, Distance_[4] : [0 5 8 ∞]</li>
                            <li>i = 3 : Since ( 5 + 1) = 6,Distance_[4]  : [0 5 8 6]</li>
                            
                        </ul>
                    </div>
                    <div style="text-align: center;">
                        <p>And assign Parent[Node] = Minimum_index</p>
                    </div>
                </ul>
            </div>
            <div>
                <p><b>Iteration-3 :</b></p>
                <ul><li>Again,Minimum_Value = 6 & Minimum_index = 3</li></ul>
            </div>
            <div>
                <ul>
                    <li>Now, mark the index which is visited in the Visit_check array.</li>
                    <div style="text-align: center;">
                        <p>Visit_check[4] : [T T F T]</p>
                    </div>
                    <li>Now, check the minimum distance between its adjacent nodes, by a loop which will execute only if,</li>
                    <div style="margin-left: 400px;">
                        <ul>
                            <li>i = 0 : Not execute, as Visit_check is True.</li>
                            <li>i = 1 : Not execute, as Visit_check is True.</li>
                            <li>i = 2 : Since ( 5 + 9 ) > 8, Distance_[4] : [0 5 8 6]</li>
                            <li>i = 3 : Not execute, as Visit_check is True.</li>
                            
                        </ul>
                    </div>
                    <div style="text-align: center;">
                        <p>And assign Parent[Node] = Minimum_index</p>
                    </div>
                </ul>
            </div>
            <div>
                <p><b>Iteration-4 : </b></p>
                <ul><li>Again,Minimum_Value = 8 & Minimum_index = 2</li></ul>
            </div>
            <div>
                <ul>
                    <li>Now, mark the index which is visited in the Visit_check array.</li>
                    <div style="text-align: center;">
                        <p>Visit_check[4] : [T T T T]</p>
                    </div>
                    <li>Now, check the minimum distance between its adjacent nodes, by a loop which will execute only if,</li>
                    <div style="margin-left: 400px;">
                        <ul>
                            <li>i = 0 : Not execute, as Visit_check is True.</li>
                            <li>i = 1 : Not execute, as Visit_check is True.</li>
                            <li>i = 2 : Not execute, as Visit_check is True.</li>
                            <li>i = 3 : Not execute, as Visit_check is True.</li>
                            
                        </ul>
                    </div>
                    <div style="text-align: center;">
                        <p>And assign Parent[Node] = Minimum_index</p>
                    </div>
                </ul>
            </div>
            <div>
                <h3 class="introh3">Pseudocode :</h3>
                <p>Function Dijkstra()</p>
                <div style="margin-left: 25px;">
                    <p>For each node in graph.dijkstra :</p>
                </div>
                <div style="margin-left: 50px;">
                    <p>Distance[node] <- Infinity</p>
                    <p>Visit_check[node] <- False</p>
                    <p>Parent[node] <- 0</p>
                    <p>Distance[source] <- 0</p>
                </div>
                <div style="margin-left: 25px;">
                    <p>For each node upto last second node in graph.dijkstra :</p>
                </div>
                <div style="margin-left: 35px;"> 
                    <p>For each node in graph.dijkstra :</p>
                </div>
                <div style="margin-left: 50px;">
                    <p>Min_Value <- Infinity</p>
                    <p>Min_index <- (-1)</p>
                    <p>If ( Visit_check[node] == false ) AND ( distance[node] < min_value )</p>
                </div>
                <div style="margin-left: 70px;">
                     <p>Min_value <- distance[node]</p>
                     <p>Min_index <- node</p>
                </div>
                <div style="margin-left: 50px;">
                     <p>Return Min_index</p>
                     <p>Visit_check[node] == true</p>
                     <p>For each node in graph.dijkstra :</p>
                </div>
                <div style="margin-left: 70px;">
                     <p>If (Visit_check[node] == false) AND
                        (distance[Min_index] + cost[Min_index][node] < distance[node]) AND
                        (cost[Min_index][node] not equals Infinity )
                    </p>
                </div>
                <div style="margin-left: 90px;">
                     <p>distance[Min_index] + cost[Min_index][node] <- distance[node]</p>
                     <p>parent[node] <- min_index</p>
                </div>
                <div style="margin-left: 70px;">
                    <p>Print distance[node], parent[node]</p>
                </div>
            </div>
            <div>
                <h3 class="introh3">Advantages :</h3>
                <div style="margin-left: 75px;">
                    <ul>
                        <li>Its time complexity is small (almost linear).</li>
                        <li>It works on one source – all pair path, so it gives all the possible shortest.</li>
                        <li>It works well for directed weighted graphs with non-negative
                            weights</li>
                    </ul>
                </div>
            </div>
            <div>
                <h3 class="introh3">Disadvantages :</h3>
                <div style="margin-left: 75px;">
                    <ul>
                        <li>It takes a blind scan, which also scans the broader unwanted area in the process, hence it increases the processing time in large graphs.</li>
                        <li>It only works for positive weighted graphs, and fails when negative weighted graphs comes into the picture.</li>
                        <li>It fails to maintain the sharp edges, which produces the acyclic graph and thus the required shortest path is difficult/impossible to get.</li>
                    </ul>
                </div>
            </div>
            
            <div>
                <h3 class="introh3">Time Complexity : </h3>
                <p>O(v^2) where v is vertex</p>
            </div>
        </div>
    </div>
    </div>
    <div data-pym-src="https://www.jdoodle.com/embed/v0/6fKJ?stdin=0&arg=0" style="color: black;"></div>
    <script src="https://www.jdoodle.com/assets/jdoodle-pym.min.js" type="text/javascript">
    </script>

</body>
<footer>
    <a href="index.html"><i id="hicon" class="fa fa-home"></i></a>
    <a href="bellmanford.html"><i id="rarrow" class="fa fa-arrow-right"></i></a>
    <p id="bf" style="color: white;">Bellman Ford</p>
</footer>

</html>